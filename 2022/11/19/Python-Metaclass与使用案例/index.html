<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Python Metaclass元类与使用案例 | Skyline Web &amp; AI Club</title><meta name="author" content="Skyline &amp; Web AI Club"><meta name="copyright" content="Skyline &amp; Web AI Club"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Metaclass 是 Python 里相对比较冷门的一个话题，使用元类可以在类创建过程中进行修改，实现一些很有意思的东西，比如单例和方法重载 type 三参数动态创建类类也是对象在 Python 中，万物皆是对象，即使是类本身，也是由所谓的元类实例化出来的。对于一个实例，可以通过type查看其对应的类型。 123class A(): ...a &#x3D; A()    # repr(a) -&gt; &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Metaclass元类与使用案例">
<meta property="og:url" content="https://www.swac.tech/2022/11/19/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/">
<meta property="og:site_name" content="Skyline Web &amp; AI Club">
<meta property="og:description" content="Metaclass 是 Python 里相对比较冷门的一个话题，使用元类可以在类创建过程中进行修改，实现一些很有意思的东西，比如单例和方法重载 type 三参数动态创建类类也是对象在 Python 中，万物皆是对象，即使是类本身，也是由所谓的元类实例化出来的。对于一个实例，可以通过type查看其对应的类型。 123class A(): ...a &#x3D; A()    # repr(a) -&gt; &amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.swac.tech/img/cover5.webp">
<meta property="article:published_time" content="2022-11-19T18:48:32.000Z">
<meta property="article:modified_time" content="2022-11-23T16:37:12.453Z">
<meta property="article:author" content="Skyline &amp; Web AI Club">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="描述器">
<meta property="article:tag" content="元类">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.swac.tech/img/cover5.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.swac.tech/2022/11/19/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python Metaclass元类与使用案例',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-23 09:37:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://cdn.plyr.io/3.7.8/plyr.js"></script><link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" /><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> Posts</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover5.webp')"><!--video player--><div class="video-wrapper" id="promo-wrapper"><div class="video-aspect-ratio-wrapper"><div class="video-close" id="promo-close"></div><video class="video-js vjs-theme-forest" id="video-fullscreen"><source src="/img/swac.mp4" type="video/mp4"></video></div></div><a href="/"><img id="site-name-img-top" src="/img/icon-text-light.png" alt="Skyline Web &amp; AI Club"></a><div id="post-info"><h1 class="post-title">Python Metaclass元类与使用案例</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-19T18:48:32.000Z" title="Created 2022-11-19 11:48:32">2022-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-23T16:37:12.453Z" title="Updated 2022-11-23 09:37:12">2022-11-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python Metaclass元类与使用案例"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><nav id="nav"><span id="blog_name"><a id="site-name" href="/"><img id="site-name-img" src="/img/icon-text-dark.png" alt="Skyline Web &amp; AI Club"/></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> Posts</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Metaclass 是 Python 里相对比较冷门的一个话题，使用元类可以在类创建过程中进行修改，实现一些很有意思的东西，比如<strong>单例</strong>和<strong>方法重载</strong></p>
<h2 id="type-三参数动态创建类"><a href="#type-三参数动态创建类" class="headerlink" title="type 三参数动态创建类"></a><code>type</code> 三参数动态创建类</h2><h3 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h3><p>在 Python 中，万物皆是对象，即使是类本身，也是由所谓的<strong>元类</strong>实例化出来的。对于一个实例，可以通过<code>type</code>查看其对应的类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(): ...</span><br><span class="line">a = A()    <span class="comment"># repr(a) -&gt; &lt;__main__.A object at 0x00000216F2C0E050&gt;</span></span><br><span class="line">B = <span class="built_in">type</span>(a)</span><br></pre></td></tr></table></figure>
<p>注意<code>type(a)</code>返回的并不是字符串，而是创建了<code>a</code>的类<code>A</code>的对象，也就是说下列的操作都是合法的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = B()    <span class="comment"># repr(c) -&gt; &lt;__main__.A object at 0x00000216F2C0DA50&gt;</span></span><br><span class="line"><span class="built_in">print</span>(B <span class="keyword">is</span> A)   <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>既然<code>type(x)</code>返回创建了<code>x</code>的对象，那么所有的类必然也由一个<strong>元类</strong>创建。如果没有特别写出指定的元类，则会默认为<code>type</code>，<br>也就是说<code>a</code>是<code>A</code>类的对象，而<code>A</code>是<code>type</code>的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(A)    <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(a) <span class="keyword">is</span> A    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">type</span>(A) <span class="keyword">is</span> <span class="built_in">type</span>    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>) <span class="keyword">is</span> <span class="built_in">type</span>    <span class="comment"># True</span></span><br><span class="line"><span class="comment"># type --实例化--&gt; A --实例化--&gt; a</span></span><br><span class="line"><span class="comment"># a --对象--&gt; A --对象--&gt; type </span></span><br></pre></td></tr></table></figure>

<h3 id="class关键字是个语法糖"><a href="#class关键字是个语法糖" class="headerlink" title="class关键字是个语法糖"></a><code>class</code>关键字是个语法糖</h3><p><code>type</code>的单参数形式将返回对象的类型，而三参数形式则将返回一个新创建的类：<code>type(name, bases, namespace)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td><code>str</code></td>
<td>类的名字 (<code>__qualname__</code>属性)</td>
</tr>
<tr>
<td><code>bases</code></td>
<td><code>tuple[type]</code></td>
<td>父类 (<code>__mro__</code>)</td>
</tr>
<tr>
<td><code>namespace</code></td>
<td><code>Mapping[str, Any]</code></td>
<td>类里的属性 (<strong>不是<code>__dict__</code>!</strong>)</td>
</tr>
</tbody></table>
<p>举个例子，下面的两种创建类的方法是差不多的，两个<code>A</code>都有<code>x</code>属性和<code>hi</code>方法，<code>class</code>关键字到最后还是会调用<code>type</code>三参数创建类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;hi from <span class="subst">&#123;self&#125;</span>&quot;</span>) </span><br><span class="line"><span class="comment"># --------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hi</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;hi from <span class="subst">&#123;self&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B,), &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;hi&quot;</span>: hi&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="类的创建过程"><a href="#类的创建过程" class="headerlink" title="类的创建过程"></a>类的创建过程</h3><p>之所以上面的两个<code>A</code>不完全一样是因为使用<code>class</code>关键字的方法会先调用对应元类的<code>__prepare__</code>方法生成<code>namespace</code>容器，再以这个容器为<code>locals</code>运行类定内的代码，且添加比如<code>__module__</code>, <code>__annotation__</code>等元信息。使用<code>class</code>关键字创建类<code>B</code>的大致流程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hi!&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">y = 2</span></span><br><span class="line"><span class="string">def hello(self):</span></span><br><span class="line"><span class="string">    print(f&quot;Hello from &#123;self&#125;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">namespace = <span class="built_in">type</span>.__prepare__(<span class="string">&quot;B&quot;</span>, (A,))    <span class="comment"># type.__prepare__ 永远返回空字典</span></span><br><span class="line"><span class="built_in">exec</span>(code, <span class="built_in">globals</span>(), namespace)</span><br><span class="line"><span class="comment"># namespace: &#123;&#x27;y&#x27;: 2, &#x27;hello&#x27;: &lt;function hello at 0x000002EECCD81510&gt;&#125;</span></span><br><span class="line"><span class="comment"># 添加 __module__, __qualname__, 和 __annotation__ （如果有的话）</span></span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (A,), namespace)</span><br></pre></td></tr></table></figure>
<p>那么元类的目的就很明显了——自定义类创建的流程。</p>
<h3 id="type关键字参数与-init-subclass"><a href="#type关键字参数与-init-subclass" class="headerlink" title="type关键字参数与__init_subclass__"></a><code>type</code>关键字参数与<code>__init_subclass__</code></h3><p>子类在继承父类时可以通过关键字参数给予父类一些信息，这些信息会被父类的<code>__init_subclass__</code>接收到，比如下面的动态生成<code>repr</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rank</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, prefix</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;[<span class="subst">&#123;prefix&#125;</span>] 级别玩家&quot;</span></span><br><span class="line">        cls.__repr__ = __repr__</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vip</span>(Rank, prefix=<span class="string">&quot;VIP&quot;</span>): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mvp</span>(Rank, prefix=<span class="string">&quot;MVP&quot;</span>): ...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Vip(), Mvp())    <span class="comment"># [VIP] 级别玩家 [MVP] 级别玩家</span></span><br></pre></td></tr></table></figure>
<p>而这些信息则在类创建时以<strong>关键字</strong>参数的方式传给了元类，类似这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vip = <span class="built_in">type</span>(<span class="string">&quot;Vip&quot;</span>, (Rank,), &#123;&#125;, prefix=<span class="string">&quot;VIP&quot;</span>)</span><br><span class="line">Mvp = <span class="built_in">type</span>(<span class="string">&quot;Vip&quot;</span>, (Rank,), &#123;&#125;, prefix=<span class="string">&quot;MVP&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Hello-world-Metaclass"><a href="#Hello-world-Metaclass" class="headerlink" title="Hello world, Metaclass!"></a>Hello world, Metaclass!</h2><h3 id="创建一个最基本的元类"><a href="#创建一个最基本的元类" class="headerlink" title="创建一个最基本的元类"></a>创建一个最基本的元类</h3><p>所有<code>mro</code>里有<code>type</code>的类就是元类，要创建一个最简单的元类，只需要继承于<code>type</code>类。我创建了<code>MyMeta</code>元类，而在这里面也只是把传到<code>__prepare__</code>和<code>__new__</code>的参数打印出来了。绝大多数情况下元类最后还是会依托于<code>type</code>，由<code>type</code>完成真正的类创建，而自己只修改一些参数或者添加一些方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;In MyMeta __prepare__: <span class="subst">&#123;mcs=&#125;</span>, <span class="subst">&#123;name=&#125;</span>, <span class="subst">&#123;bases=&#125;</span>, <span class="subst">&#123;kwargs=&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__prepare__(name, bases)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;In MyMeta __new__: <span class="subst">&#123;mcs=&#125;</span>, <span class="subst">&#123;name=&#125;</span>, <span class="subst">&#123;bases=&#125;</span>, <span class="subst">&#123;namespace=&#125;</span>, <span class="subst">&#123;kwargs=&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, namespace, **kwargs)</span><br></pre></td></tr></table></figure>
<p>要使用Metaclass，只需要将类定义上添加上<code>metaclass=MyMeta</code>即可，值得注意的是这个参数并不会传给任何<code>__init_subclass__</code>方法，甚至在元类的<code>__prepare__</code>方法的<code>kwargs</code>内都找不到<code>&#123;&quot;metaclass&quot;: MyMeta&#125;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=MyMeta):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;hello from <span class="subst">&#123;self&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在定义这个类时，产生了如下的输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In MyMeta __prepare__: mcs=&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.MyMeta&#x27;</span>&gt;, name=<span class="string">&#x27;A&#x27;</span>, bases=(), kwargs=&#123;&#125;</span><br><span class="line">In MyMeta __new__: mcs=&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.MyMeta&#x27;</span>&gt;, name=<span class="string">&#x27;A&#x27;</span>, bases=(), namespace=&#123;</span><br><span class="line">    <span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;__qualname__&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="string">&#x27;hi&#x27;</span>: &lt;function A.hi at <span class="number">0x000001E952AFB370</span>&gt;</span><br><span class="line">&#125;, kwargs=&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个<code>A</code>类的对象<code>a</code>，再来看看现在谁创建了谁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line"><span class="built_in">type</span>(a)    <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(a))    <span class="comment"># &lt;class &#x27;__main__.MyMeta&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a)))   <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以看见，即使是制造其他类的元类，也是由<code>type</code>这个“超元类”创建的。</p>
<h3 id="使用元类实现单例模式"><a href="#使用元类实现单例模式" class="headerlink" title="使用元类实现单例模式"></a>使用元类实现单例模式</h3><p>假设你在开发一款游戏，而这个游戏需要一个 <strong>全局设置 (Config)</strong> 类，由于全局设置的特殊性，无论怎么实例化应当总是拿到同一个对象(<code>Config() is Config()</code>)，这种一个类只创建一个对象的设计模式被称为 <strong>单例 (Singleton)</strong><br>最简单的方法就是当一个类的<code>__call__</code>方法被调用时永远返回同一个实例。在Python中，<code>__call__</code>方法就是在一个对象后面加括号，即<code>Config()</code> 与 <code>Config.__call__()</code>是等效的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):    <span class="comment"># A() 时被调用</span></span><br><span class="line">        <span class="built_in">print</span>(cls)    <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (instance := <span class="built_in">getattr</span>(cls, <span class="string">&quot;_instance&quot;</span>, <span class="literal">None</span>)) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = instance = <span class="built_in">super</span>().__call__(*args, **kwargs)    <span class="comment"># 交给 type 类处理</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=SingletonMeta):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A() <span class="keyword">is</span> A())    <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>在这段代码里，<code>SingletonMeta</code>并没有更改<code>A</code>类创建时的特性，而是在<code>A</code>尝试在实例化时检查其<code>__dict__</code>里有没有<code>_instance</code>属性，如果有的话就直接返回那个<code>_instance</code><br>如果你对于为什么<code>A()</code>会调用<code>SingletonMeta.__call__</code>感到疑惑的话，不妨试试这么理解：</p>
<ul>
<li>现在有一个类<code>Add</code>实现了<code>__add__</code>方法<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">       <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>这个<code>__add__</code>方法是蓝图——只有<code>Add</code>类的对象相加时会调用<code>A.__add__</code>，在类层面上相加会报错<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = Add()</span><br><span class="line"><span class="built_in">print</span>(add + <span class="number">1</span>)    <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(Add + <span class="number">1</span>)    <span class="comment"># TypeError: unsupported operand type(s) for +: &#x27;type&#x27; and &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>那么<code>A</code>类既然是<code>SingletonMeta</code>的对象，自然会找到<code>SingletonMeta</code>上的方法<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = SingletonMeta(<span class="string">&quot;A&quot;</span>, (), &#123;&#125;)</span><br><span class="line">A()    <span class="comment"># 调用 SingletonMeta 的 __call__</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="Python伪输出流"><a href="#Python伪输出流" class="headerlink" title="Python伪输出流"></a>Python伪输出流</h3><p>可以通过在元类定义<code>__lshift__</code>与<code>__rlshift__</code>方法在类的层面上伪造输出流：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lshift__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Flush): <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        <span class="built_in">print</span>(other, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flush</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rlshift__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cout</span>(metaclass=Stream): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">endl</span>(metaclass=Flush): ...</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; Hello world! &quot;</span> &lt;&lt; Flush &lt;&lt; endl    <span class="comment"># 1 Hello world! &lt;class &#x27;__main__.Flush&#x27;&gt; </span></span><br></pre></td></tr></table></figure>
<p>Python 对于运算符有两套魔法方法，带<code>r</code>的和不带<code>r</code>的，其区别是 Python 会先调用 <code>left.__OP__(right)</code>，如果返回了 <code>NotImplemented</code> 则会尝试 <code>right.__rOP__(left)</code>，如果都失败了才会报错。</p>
<h3 id="简易版抽象类：AbstractBaseClass"><a href="#简易版抽象类：AbstractBaseClass" class="headerlink" title="简易版抽象类：AbstractBaseClass"></a>简易版抽象类：AbstractBaseClass</h3><p>Python 的抽象类正式基于元类实现的，简化版实现思路：</p>
<ol>
<li>使用一个装饰器将某些方法标为抽象方法<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abstractmethod</span>(<span class="params">f</span>):</span><br><span class="line">  f.__abstract__ = <span class="literal">True</span></span><br><span class="line">  <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>在<code>__call__</code>方法上做手脚，确保所有方法都不是抽象的才实例化，反之报错<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBaseClassMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">any</span>(</span><br><span class="line">           attr <span class="keyword">for</span> _, attr <span class="keyword">in</span></span><br><span class="line">           itertools.chain(</span><br><span class="line">               *(super_cls.__dict__.items() <span class="keyword">for</span> super_cls <span class="keyword">in</span> cls.__mro__[:-<span class="number">2</span>])</span><br><span class="line">           )    <span class="comment"># 当前类到ABC（不包括）的所有属性</span></span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">hasattr</span>(attr, <span class="string">&quot;__abstract__&quot;</span>)</span><br><span class="line">       ):</span><br><span class="line">           <span class="keyword">raise</span> TypeError(<span class="string">&quot;抽象类有未实现的方法！&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>用一些手段使得用户在不知道的情况下将元类设置为<code>ABCMeta</code>。相比于挂在类上的装饰器，元类会被继承，所以可以创建一个空的类并设置其元类属性，用户在使用时只需要继承与这个空类即可<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBaseClass</span>(metaclass=AbstractBaseClassMeta):</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>使用方法也很简单，只需要将父类方法标记上<code>@abstractmethod</code>然后子类重写的时候把<code>__abstract__</code>属性顶替掉就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Abstract</span>(<span class="title class_ inherited__">AbstractBaseClass</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>): ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete</span>(<span class="title class_ inherited__">Abstract</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlsoAbstract</span>(<span class="title class_ inherited__">Abstract</span>): ...</span><br><span class="line">        </span><br><span class="line">Concrete().greet()    <span class="comment"># hello</span></span><br><span class="line">Abstract()    <span class="comment"># TypeError</span></span><br><span class="line">AlsoAbstract()    <span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="Python，但是可以方法重载"><a href="#Python，但是可以方法重载" class="headerlink" title="Python，但是可以方法重载"></a>Python，但是可以方法重载</h2><blockquote>
<p>代码来自<a target="_blank" rel="noopener" href="https://github.com/mCodingLLC/VideosSampleCode/blob/master/videos/077_metaclasses_in_python/overloading.py">这个repo</a>，以 MIT 协议开源</p>
</blockquote>
<p>先来看看效果，通过元类使得同名方法可以有不同的参数类型或者参数列表，即使有继承关系也可以完美兼容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Overload</span>):</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A.f 整形重载&quot;</span>, self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, x: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A.f 字符串重载&quot;</span>, self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A.f 两参数重载&quot;</span>, self, x, y)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B.f 无参重载&quot;</span>, self)</span><br><span class="line"></span><br><span class="line">a, b = A(), B()</span><br><span class="line"></span><br><span class="line">b.f(<span class="number">1</span>, <span class="number">2</span>)    <span class="comment"># A.f 两参数重载</span></span><br><span class="line">b.f(<span class="number">1</span>)    <span class="comment"># A.f 整形重载</span></span><br><span class="line">b.f(<span class="string">&quot;str&quot;</span>)    <span class="comment"># A.f 字符串重载</span></span><br><span class="line">b.f()    <span class="comment"># B.f 无参重载</span></span><br></pre></td></tr></table></figure>

<h3 id="狸猫换太子之-prepare-返回OverloadDict"><a href="#狸猫换太子之-prepare-返回OverloadDict" class="headerlink" title="狸猫换太子之__prepare__返回OverloadDict"></a>狸猫换太子之<code>__prepare__</code>返回<code>OverloadDict</code></h3><p>上面说到了<code>type.__prepare__</code>永远会返回一个空字典，然后使用这个字典作为<code>locals</code>运行类定义内的代码，获取到这个<code>namespace</code>字典，最后在传给<code>type.__new__</code>完成类的创建。<code>OverloadMeta</code>将重写这个<code>__prepare__</code>方法并返回一个<code>OverloadDict</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OverloadMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases</span>):</span><br><span class="line">        <span class="keyword">return</span> OverloadDict()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):    <span class="comment"># 不是最终代码</span></span><br><span class="line">        <span class="built_in">print</span>(namespace)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, namespace, **kwargs)</span><br></pre></td></tr></table></figure>
<p>而这个<code>OverloadDict</code>的任务，就是保证相同名字的方法在被放进这个字典里的时候不会将上一个顶掉，所以重写<code>__setitem__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OverloadList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverloadDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    __MISSING = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>), <span class="string">&quot;keys must be str&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先检查自己有没有存过一模一样的东西，因为 None 是合法值 (比如在类里写 x = None) </span></span><br><span class="line">        prior_val = self.get(key, self.__MISSING)     </span><br><span class="line">        overloaded = <span class="built_in">getattr</span>(value, <span class="string">&quot;__overload__&quot;</span>, <span class="literal">False</span>)  <span class="comment"># 检查函数是不是被标记为重载</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prior_val <span class="keyword">is</span> self.__MISSING:   <span class="comment"># 如果字典内没有记录过相同的方法</span></span><br><span class="line">            <span class="comment"># 如果被标记为 overload 则新建一个 OverloadList 然后丢到字典里去</span></span><br><span class="line">            insert_val = OverloadList([value]) <span class="keyword">if</span> overloaded <span class="keyword">else</span> value</span><br><span class="line">            <span class="built_in">super</span>().__setitem__(key, insert_val)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果不使用 OverloadList 就分不清是存了两次列表 (x = []; x = [1, 2]) 还是真的重载了</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(prior_val, OverloadList):    </span><br><span class="line">            <span class="comment"># 如果存过一模一样的东西，而且也被标记为 overload，那么就往 OverloadList 里添加这个对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> overloaded:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(self._errmsg(key))     <span class="comment"># 前后不一致——有的是重载有的不是</span></span><br><span class="line">            prior_val.append(value)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> overloaded:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(self._errmsg(key))     <span class="comment"># 前后不一致——有的是重载有的不是</span></span><br><span class="line">            <span class="built_in">super</span>().__setitem__(key, value)     <span class="comment"># 刻意的覆盖 (x = 1; x = 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_errmsg</span>(<span class="params">key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;部分方法重载部分没有，需要所有方法都标记为 @overload: <span class="subst">&#123;key&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>OverloadList</code>的作用就是为了区分到底是函数重载还是刻意的列表重复定义，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=OverloadMeta):    <span class="comment"># 现在这个元类还不能正常工作，只是一个例子</span></span><br><span class="line">    x = []</span><br><span class="line">    x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>如果存储重载的方法不使用<code>OverloadList</code>而全部用<code>list</code> (将所有<code>OverloadList</code>换成<code>list</code>)，就会出bug：</p>
<ol>
<li><code>OverloadDict</code>没有存过名叫<code>x</code>的变量，将<code>x</code>和空列表存到字典里</li>
<li>当运行到<code>x = [1, 2, 3]</code>时，<code>OverloadDict</code>在第七行拿到空列表，而第十七行的<code>elif isinstance(prior_val, list)</code>会被判定为<code>True</code></li>
<li>因为<code>[1, 2, 3]</code>这个列表没有<code>__overload__</code>属性，所以会在第二十行报错，前后不一致</li>
</ol>
<p>在<code>OverloadMeta.__new__</code>开始之前这个<code>OverloadDict</code>就已经有了该有的属性，以上面的<code>A</code>类为例子，<code>OverloadMeta.__new__</code>打印出来的命名空间为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;__module__&#x27;: &#x27;__main__&#x27;,</span><br><span class="line">    &#x27;__qualname__&#x27;: &#x27;A&#x27;, </span><br><span class="line">    &#x27;f&#x27;: [&lt;function A.f at 0x0000012B8D29B5B0&gt;, &lt;function A.f at 0x0000012B8D29B640&gt;, &lt;function A.f at 0x0000012B8D29B6D0&gt;]</span><br><span class="line">    这里的 f 仍然是 OverloadList，只是没有重写 list 的 __repr__ 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表变方法，描述器显神功"><a href="#列表变方法，描述器显神功" class="headerlink" title="列表变方法，描述器显神功"></a>列表变方法，描述器显神功</h3><p>如果在<code>OverloadMeta.__new__</code>里直接调用<code>type.__new__</code>，生产出来的类，比如<code>A</code>类，在获取<code>f</code>方法的时候拿到的将会是一个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.f)    <span class="comment"># [&lt;function A.f at ...&gt;, &lt;function A.f at ...&gt;, &lt;function A.f at ...&gt;]</span></span><br><span class="line">a.f(<span class="number">1</span>, <span class="number">2</span>)   <span class="comment"># TypeError: OverloadList object is not callable</span></span><br></pre></td></tr></table></figure>
<p><strong>我们想要一个方法，在实例<code>a</code>调用被重载的方法时，将拿到一个方法而非一个重载列表。</strong><br>这种情况下，<a href="/2022/11/21/Python-%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%B7%B1%E5%85%A5%E7%AE%80%E5%87%BA"><strong>描述器 (descriptor)</strong></a> 将非常有用。一个类只要定义了<code>__get__</code>, <code>__set__</code>, <code>__delete__</code>中任意一个方法就被叫做描述器，下面有一个很简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Desc</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;GET: <span class="subst">&#123;instance=&#125;</span>, <span class="subst">&#123;owner=&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    desc = Desc()</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c.desc)    <span class="comment"># GET: instance=&lt;__main__.C object at 0x000002282914FEE0&gt;, owner=&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line">                 <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<p>可以看见，被放置在类体内的描述器在被获取时将调用对应的<code>__get__</code>方法，我们需要的就是这一点，在做<code>a.f</code>的时候添加逻辑，返回正确的对象。<br>先把所有的<code>OverloadList</code>在<code>__new__</code>里转成<code>OverloadDesc</code>，并把修改过的命名空间传给<code>type.__new__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OverloadMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases</span>):</span><br><span class="line">        <span class="keyword">return</span> OverloadDict()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        overload_namespace = &#123;</span><br><span class="line">            key: OverloadDesc(val) <span class="keyword">if</span> <span class="built_in">isinstance</span>(val, OverloadList) <span class="keyword">else</span> val</span><br><span class="line">            <span class="keyword">for</span> key, val <span class="keyword">in</span> namespace.items()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, overload_namespace, **kwargs)</span><br></pre></td></tr></table></figure>
<p>现在来看看这个<code>OverloadDesc</code>描述器干了什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OverloadDesc</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_name__</span>(<span class="params">self, owner, name</span>):</span><br><span class="line">        self.owner = owner  <span class="comment"># 在哪个类下，比如 &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line">        self.name = name    <span class="comment"># 方法的名字，比如 f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, overload_list</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(overload_list, OverloadList):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;必须是重载列表&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> overload_list:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;空的重载列表&quot;</span>)</span><br><span class="line">        self.overload_list = overload_list</span><br><span class="line">        self.signatures = [inspect.signature(f) <span class="keyword">for</span> f <span class="keyword">in</span> overload_list]     <span class="comment"># 获取每个方法的 signature</span></span><br><span class="line">        <span class="comment"># 比如：[&lt;Signature (self, x: int)&gt;, &lt;Signature (self, x: str)&gt;, &lt;Signature (self, x, y)&gt;]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.__class__.__qualname__&#125;</span>(<span class="subst">&#123;self.overload_list!r&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance=<span class="literal">None</span>, _owner=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 如果是直接 A.f 而不是 a.f 就返回自己</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="comment"># 要不然就返回一个知道所有信息的类</span></span><br><span class="line">        <span class="keyword">return</span> BoundOverloadDispatcher(instance, self.owner, self.name, self.overload_list, self.signatures)</span><br></pre></td></tr></table></figure>
<p>最重要的时最后一行返回的<code>BoundOverloadDispatcher</code>，如果调用<code>a.f(1)</code>，首先会先获取到<code>a.f</code>，然后再调用对应的<code>__call__</code>方法。描述器只能帮我们到获取<code>a.f</code>，由于只有调用的时候有参数列表而获取时没有，所以需要一个类专门根据<code>__call__</code>传进来的参数列表调用不同的重载方法，而这个类就是<code>BoundOverloadDispatcher</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoMatchingOverload</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundOverloadDispatcher</span>:</span><br><span class="line">    __MISSING = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, instance, owner_cls, name, overload_list, signatures</span>):</span><br><span class="line">        self.instance = instance    <span class="comment"># 方法的第一个 self 参数</span></span><br><span class="line">        self.owner_cls = owner_cls</span><br><span class="line">        self.name = name</span><br><span class="line">        self.overload_list = overload_list</span><br><span class="line">        self.signatures: <span class="built_in">list</span>[inspect.Signature] = signatures</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">best_match</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> f, sig <span class="keyword">in</span> <span class="built_in">zip</span>(self.overload_list, self.signatures):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                bound_func = sig.bind(self.instance, *args, **kwargs)    <span class="comment"># 参数列表能不能对的上</span></span><br><span class="line">            <span class="keyword">except</span> TypeError:   <span class="comment"># 如果参数列表都不对那就寻找下一个</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bound_func.apply_defaults()     <span class="comment"># 将默认参数补齐</span></span><br><span class="line">                <span class="keyword">if</span> _signature_matches(sig, bound_func):     <span class="comment"># 如果类型提示也通过了那就是这个</span></span><br><span class="line">                    <span class="keyword">return</span> f</span><br><span class="line">        <span class="keyword">raise</span> NoMatchingOverload()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = self.best_match(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> NoMatchingOverload:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> f(self.instance, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 没有匹配的，查找父类</span></span><br><span class="line">        super_ins = <span class="built_in">super</span>(self.owner_cls, self.instance)</span><br><span class="line">        <span class="comment"># 获取父类同名方法（实际上是BoundOverloadDispatcher）</span></span><br><span class="line">        super_call = <span class="built_in">getattr</span>(super_ins, self.name, self.__MISSING)</span><br><span class="line">        <span class="keyword">if</span> super_call <span class="keyword">is</span> <span class="keyword">not</span> self.__MISSING:</span><br><span class="line">            <span class="keyword">return</span> super_call(*args, **kwargs)    <span class="comment"># 递归往父类找</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NoMatchingOverload()</span><br></pre></td></tr></table></figure>
<p>第22行的<code>_signature_matches</code>检查了类型提示和传进来的参数是否一致，值得一提的是<code>isinstance(obj, Union[str, int])</code>之类的都可以正常的判断，唯独就是<code>list[int]</code>这种不行，因为<code>isinstance</code>不支持泛型类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_signature_matches</span>(<span class="params">signature: inspect.Signature, bound_args: inspect.BoundArguments</span>):</span><br><span class="line">    <span class="keyword">for</span> name, arg <span class="keyword">in</span> bound_args.arguments.items():</span><br><span class="line">        param = signature.parameters[name]</span><br><span class="line">        hint = param.annotation</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _typehint_matches(arg, hint):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_typehint_matches</span>(<span class="params">obj, hint</span>):</span><br><span class="line">    <span class="keyword">return</span> hint <span class="keyword">is</span> inspect.Parameter.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(obj, hint)</span><br></pre></td></tr></table></figure>

<h3 id="装饰器和空类"><a href="#装饰器和空类" class="headerlink" title="装饰器和空类"></a>装饰器和空类</h3><p>到这里所有的逻辑都已经完成了，为了用户的使用简便度，创建一个<code>@overload</code>装饰器和<code>Overload</code>用来继承。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">overload</span>(<span class="params">f</span>):</span><br><span class="line">    f.__overload__ = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Overload</span>(metaclass=OverloadMeta):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="重载的工作流程"><a href="#重载的工作流程" class="headerlink" title="重载的工作流程"></a>重载的工作流程</h3><p>前面讲了这么多代码，这一节我来梳理一下为什么<code>A</code>类可以重载。为了方便我再把代码放在这里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Overload</span>):</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A.f 整形重载&quot;</span>, self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, x: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A.f 字符串重载&quot;</span>, self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A.f 两参数重载&quot;</span>, self, x, y)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B.f 无参重载&quot;</span>, self)</span><br></pre></td></tr></table></figure>
<ul>
<li>类的创建<ol>
<li><code>A</code>类继承于<code>Overload</code>类，而<code>Overload</code>设置了元类为<code>OverloadMeta</code>，也就是说<code>A</code>类是由<code>OverloadMeta</code>创建的类。</li>
<li>首先在<code>OverloadMeta.__prepare__</code>里返回了一个特制的<code>OverloadDict</code>对象，其作用就是将重载的同名属性都丢到<code>OverloadList</code>对象里去。</li>
<li>在<code>__prepare__</code>与<code>__new__</code>之间运行了<code>A</code>类定义内部的代码，所有的局部变量都被保存到<code>OverloadDict</code>对象里，也就是命名空间。</li>
<li>命名空间被传进<code>OverloadMeta.__new__</code>里，在这个方法里将命名空间字典里所有的<code>OverloadList</code>都套上<code>OverloadDesc</code>，变成描述器。</li>
<li>把参数交给<code>type.__new__</code></li>
</ol>
</li>
<li>获取方法并调用<ol>
<li>若使用<code>A.f</code>则返回对应的描述器，如是对象获取属性(<code>a.f</code>)则返回一个<code>BoundOverloadDispatcher</code>，因为描述器只能管到属性获取，管不到调用这个属性，因而需要这个类专门根据参数类型调用对应的方法。</li>
<li>在<code>BoundOverloadDispatcher</code>被调用的时候，会尝试在调用者的类上找对应了参数列表和参数类型的方法并调用。如果当前类找不到，则会用递归的方式向父类寻找。</li>
<li><code>_typehint_matches</code>使用了<code>isinstance</code>，所以不是所有注释都可以运行。</li>
</ol>
</li>
</ul>
<h2 id="我的父类是我的元类"><a href="#我的父类是我的元类" class="headerlink" title="我的父类是我的元类"></a>我的父类是我的元类</h2><p>从<code>type</code>到普通类的实例不一定只有3或4层关系，一个元类同样可以生产元类，甚至一个元类的父类和其元类可以是同一个，看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta1</span>(<span class="title class_ inherited__">type</span>): ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meta2</span>(Meta1, metaclass=Meta1):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rev</span>(<span class="params">mcs</span>):</span><br><span class="line">        <span class="built_in">print</span>(mcs.__bases__[<span class="number">0</span>] <span class="keyword">is</span> <span class="built_in">type</span>(mcs))    <span class="comment"># 父类和元类是不是同一个？</span></span><br><span class="line"></span><br><span class="line">Meta2.rev()    <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>而这也就代表着嵌套四次<code>type</code>并不一定会重复为<code>type</code>，比如这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta1</span>(<span class="title class_ inherited__">type</span>): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meta2</span>(Meta1, metaclass=Meta1): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meta3</span>(Meta2, metaclass=Meta2): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meta4</span>(Meta3, metaclass=Meta3): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meta5</span>(Meta4, metaclass=Meta4): ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=Meta5): ...</span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">type</span>(a)    <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(a))    <span class="comment"># &lt;class &#x27;__main__.Meta5&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a)))    <span class="comment"># &lt;class &#x27;__main__.Meta4&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a))))    <span class="comment"># &lt;class &#x27;__main__.Meta3&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a)))))    <span class="comment"># &lt;class &#x27;__main__.Meta2&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a))))))    <span class="comment"># &lt;class &#x27;__main__.Meta1&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a)))))))    <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://www.swac.tech">Skyline &amp; Web AI Club</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.swac.tech/2022/11/19/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/">https://www.swac.tech/2022/11/19/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/">描述器</a><a class="post-meta__tags" href="/tags/%E5%85%83%E7%B1%BB/">元类</a></div><div class="post_share"><div class="social-share" data-image="/img/cover5.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/05/hello-world/"><img class="prev-cover" src="/img/cover2.webp" onerror="onerror=null;src='/img/default_cover.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Skyline &amp; Web AI Club</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FedDragon1"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://twitter.com/shswebai_club" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="https://discord.gg/hzC7MMkySY" target="_blank" title="Discord Server"><i class="fab fa-discord"></i></a><a class="social-icon" href="https://www.instagram.com/shswebaiclub/" target="_blank" title="Instagram"><i class="fab fa-instagram"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Hiring video editor! Contact us if you are good at AE & C4D</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#type-%E4%B8%89%E5%8F%82%E6%95%B0%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">type 三参数动态创建类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%9F%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">类也是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.2.</span> <span class="toc-text">class关键字是个语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">类的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E4%B8%8E-init-subclass"><span class="toc-number">1.4.</span> <span class="toc-text">type关键字参数与__init_subclass__</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-world-Metaclass"><span class="toc-number">2.</span> <span class="toc-text">Hello world, Metaclass!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%83%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">创建一个最基本的元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">使用元类实现单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%BC%AA%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">Python伪输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E7%89%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9AAbstractBaseClass"><span class="toc-number">2.4.</span> <span class="toc-text">简易版抽象类：AbstractBaseClass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">Python，但是可以方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%B8%E7%8C%AB%E6%8D%A2%E5%A4%AA%E5%AD%90%E4%B9%8B-prepare-%E8%BF%94%E5%9B%9EOverloadDict"><span class="toc-number">3.1.</span> <span class="toc-text">狸猫换太子之__prepare__返回OverloadDict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%8F%98%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%98%BE%E7%A5%9E%E5%8A%9F"><span class="toc-number">3.2.</span> <span class="toc-text">列表变方法，描述器显神功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E7%A9%BA%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">装饰器和空类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">重载的工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E7%88%B6%E7%B1%BB%E6%98%AF%E6%88%91%E7%9A%84%E5%85%83%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">我的父类是我的元类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/05/hello-world/" title="Hello World"><img src="/img/cover2.webp" onerror="this.onerror=null;this.src='/img/default_cover.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2023/08/05/hello-world/" title="Hello World">Hello World</a><time datetime="2023-08-06T01:19:09.451Z" title="Created 2023-08-05 18:19:09">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/19/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/" title="Python Metaclass元类与使用案例"><img src="/img/cover5.webp" onerror="this.onerror=null;this.src='/img/default_cover.jpg'" alt="Python Metaclass元类与使用案例"/></a><div class="content"><a class="title" href="/2022/11/19/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/" title="Python Metaclass元类与使用案例">Python Metaclass元类与使用案例</a><time datetime="2022-11-19T18:48:32.000Z" title="Created 2022-11-19 11:48:32">2022-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Skyline & Web AI Club</div><div class="footer_custom_text"></div><div id="footer_site_ontime"><p id="ontime_value">2022/10/29</p></div><div class="framework-info"><a target="_blank" rel="noopener" href="https://hexo.io"><img src="https://img.shields.io/badge/Framework-Hexo-83855d?style=flat&amp;logo=Hexo" alt="Framework: Hexo;"/></a><a target="_blank" rel="noopener" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-83855d?style=flat&amp;logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIy0lEQVR42u2bdXjbShbFs8y8%2B88yMzMzMxVMMZTrKEyPw4%2BfU2ZmBttlbh8zMzPaLtetPTu%2FzytVcSJbkpWH%2FuN%2B32junXvPOYK5kpMKIcRr2soClAUoC%2FCaF6AsQFmAMZ3Rz%2Flb58f8DdNuDrTO3xhsW9UY7Fr%2FsVcLSbjACW5whCucBQKEzl2luP%2FuEu7f%2FyXP%2Fio8%2F%2FAKr6f%2BpG9szwv%2Bc1Zc%2FEohDFYwgx0OcMnnB2e4V3h9DWkmzJh3eDgTaJm7ZUjb7ne%2B3EiDCWxgNMsH7hXuvwzhwJKhqr9u8p2h82OffqmJgwEsYLLKA%2B4VnmHjs%2F0cf5CX%2F39GCm%2FgbOFx1UjCvoGF%2BHcwGzx31RkvFXlqg2EgbGAGOxzgAqf8GLhXBBqmPKlN%2FnWo8DUvEf5pjwr%2FrGf7WGXkduGrmy2Tjeib6I%2F%2FEP766Te82OSpSW0dFrCBEaz5%2BOEENzhq8XCvGH3hmnM48LprhX%2FKQwQXtcoLrxaeytY%2BxX3Bs46N7oh%2FbbCJU4Na%2BtpgAZMZ7HCEK%2BvgXhHYLd7qDzamldWPidHLnifItFV27hKeIWN0t0QoG%2BqM%2FXawyJObGmo9aoPBCmY4whXOcK8gcc26Z6dWx5ICC69NiODc58wnnfm08NbO0rYaz39HZkf3xH%2FgNHlyklvdoqlJbbM44QQ3lSectUaoOpb4lerAlGhSjFpi8Wro2C7UHcU7bFzGyduBXORUn9zUsoINLnDSc4SzJsCQleINcvJZHHobt%2FoFEZhjQYTIbewMORFcVafUbku1SGdkz4SuCf8yIoqPGP0cOchFTnJTwywesMMhnxdc4awJgMnJ2TjzTdmYFCMWPmdehAl3Cc%2B%2F%2FLkH44hzD%2BcT7O3qTU3qmfTFfPLM4csXiBzkIie5zeIAM9gH4gRXcvcVIJr6M04jG7viBeGfbVKE3juE55%2B53kH23Rv0hCTJiLRd%2BQIwh08%2Fx1pykIucZmqDEayFuMC1nwDKJvEW6cwUWli1PiFC858zJ8IlNwr3n%2F4p3H8bLoIXxH6s1pkxY8abJNH75Jn%2BqTrHmDl86hxrWEsOcpmoCTYwFiQPR7j2EwBT4slHCCqsXlKMWW7uavC1LNN6BH2dSFfEJQlvU48Z93b3evUx6l5PDjNnHUxgK4YfjobfA6pjqf0EmTGUNvNs8PjPzN0KLfO26mq9TpK%2Bubej9weYHN%2FW1tb2etVPLGtYa%2BZeB4tZ3HAsIEBisflE2k5RuG%2BY%2FACvnrSggkZGdxXUSuJxTI7r9c0OsaxhbaF9ndpW8cLRUAAlluy2mFDrG0Yvfb5gx0jz4gu0HtcEOD%2FySUk%2BK01M6pz0KXWeGGILdXjUoqYdrHA0vgLiyZEE2bXwOuOHpHd85P%2B7woK12tn%2Bd%2BgZTD3GRwyxRg85apSCEY5GAmgdYak2dtUAt8XUh%2BniBB0dtf7147989fff%2Fr3AGDOHjxhi8y93cjqBDY6GAtSvf%2F5jBDliUSnEyr6dpK9%2Bbu419MzFS1y%2F%2B%2FMNf%2FjO7wXGmDl8xOg7OXKQyylccDQSgIPXyaBjBDplCtvmCoTIvZOzt3vd1WnIDvnVnwXGmDl8xBDLGtY6iQVucDQQQHsO7CHYaYMMr6K%2B5kXCO2RUv%2B92zOEjRiPusMGt6O8CSizxb4IHyU4p655NVI5pP5QvAHP4iBms%2BnArKgBWE010ygUn7BSp2XxQ1G09LOp3HBUNu46Lxr1p0bz%2FpGi5IiNarxICGz9xq548xpzmJ5Y1rCUHuchJbpvkT8DJ0i9D41c%2B886a%2BMG%2FVsdT4ZpY8kx5%2BVworUc%2BkJplOzmmdsuhsAR3J0CbL89I0FnAF7WmfSfFuIvX5QvAHD5TOahFTWqDASxgAhsYwQpmsMMBLo7%2BNNa4J72o5cpsFjBWrVaexfCUHcLz539q5Bkzh89OTrCAadB%2FG6zbefQjTftPPUJRO9a4%2B3juPWLiJjEqfI7w%2FvU%2FAmPMHD5i7OYHGxgHRYCGPUddzVdk0nbBtchLtiaeyglwySoR7pglwu0zMcbM4SOGWNsigBGsjgog78321iuztkGxVt6np1vmngWQ1htzmp%2FYUuuB2REBGnan%2FS0lgMHqth%2BBWM42PgfhgQyfFseaUmqCGewlC9B8IHOYhCXe95opK%2B43FACfFlvi8wADe0kCNO48FiyJ%2FN50%2F2Zk9lWGAuDLjydHKRjgYFuApt3HGx0685pV9W7U3fcLM5h6jE%2BLdehKgIN9AfYcV%2BwUbdh5zOAN8QUR7porNMIXrziMqcf4iBloLTntYIGDbQEadh8babEgbatxL778PohqVhVZ%2FyimmyPGcD25reKBg20BlE3i3aY7viuFqNt2pPDLyOwr%2Bwowaes6TDdHTKEc1KCW6Q4RDiXtAk170zea6c1rtx4u%2FiU5sqGvADP2DMF0c8QUy0MtU%2B8eYC95G2zcdeQfxZ70NZtShUFjG5%2FnHtc3PllZ4PUYY91zgNii%2BahZbIcAuyOdYPO%2B9C39z3pGXo6Hzb%2BLL7lDf%2Fbp%2Fa9X8zPW%2BYg1nRcMYMnHB2bHWuGG3Qc%2FKF8%2F06e3uBOiOtfXm7aqyduERrJztqiZcUD7aYwxc6qfWAu5wQImjTxYweyUANqO0Lj3RNbWRwm2v%2B75pwleuv7x%2FPzMqX5iWWPnYwwYwer863AJ3wuVpXf1vfyn7xqfn5s5fQxrSvzu57wANdFUlR1QVfJjh0bu0rXPGuXHp8axxk4tMA7eB5EtqffLIk9Zu%2FwTudffzjmiakLs9sC8G99rlB8fMcSyhrVWaoENjIMlgP4PKU6ZvvyX3S3o9pRpe79ltgaxrGGtlS%2FOYHtR%2Flxe2Zj4hdkrQVl869a2tt1vtFqDNaw1e%2BbB9KL%2Bv4ASTX1fFk4XvB9jyaltbeL1dmuwlhxFyKfB8pL8w4QST7kkgAcM9ubziHHCyGVA%2FgEwvKT%2FMcJZUjYd%2BlB47cEP1EYTv%2BT7vBJNfAOfk0ZOclODWtSkdvlfZsoClAUoC1AWoCxAWQDb9j9N63hK2EtncwAAAABJRU5ErkJggg%3D%3D" alt="Theme: Butterfly;"/></a><a target="_blank" rel="noopener" href="https://vercel.com/dashboard"><img src="https://img.shields.io/badge/Host%20By-Vercel-83855d?style=flat&amp;logo=Vercel" alt="Hosted By: Vercel"/></a><a target="_blank" rel="noopener" href="https://dashboard.4everland.org"><img src="https://img.shields.io/badge/Host%20By-4everland-83855d?style=flat&amp;logo=image%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAMIUlEQVR42u2aW6xc11nHf2vt69zPzcfH8QU7J3Ecx5c4OEkTRCgIKhpVQUFBRVDRB64KttIGIiRAgj4hkbQVt0rwglKQqj60aROQlTaECEMoTus6SW1iu3Z8Ofa5zpkzlz37vhYPa2%2BfU4mHgOI2UWakpT2zZ885%2B%2Fut7%2FL%2FvhmhteaD%2FJB8wB8jACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAH8CHTQey45ACuYbMgkxBGoH2wHYhz8CqQtwHbxyiIWQJYEGagnRBOhAOABtyBQoQNkQKvDFzfphzsDNgd6XJR9sDEC7kEtZi8DxYGHJeSY7PjPHaW23i5Ri0gGFurtkxBhc7MFYBIeD8GkxVzTW2hDCDxSEcmIaVEBoeaAVni%2BvunYFvXoUxHxLgYg%2Fsm07Yhjzh1iDgiFXjt5otak4FmuPmxjNgqzY3b7kwSOFqh1e7MU97Nl9L1PswBLQGATgODHv8WbfHeWXzaelS86vm%2FTCCQQTD4hilZmfGK1B3eFAonrvS4VtJzkHfNp%2B5OSFwM%2F6oC0nA7FrEP0WCPbVxcOuQA1kOuQANSGGuF4VxeQ5Sw5YG1D3IF7h%2FbsCpXs5TEzWeseX7wAMsAemQ3wsyTic%2Be8a2glczBiPNUWBiuFyWAHvDaynAd%2BC%2BrXBgCjx4eqnPP6%2BEbHffZW94VwAICbYDKA4Merw6SHnGmsBrbDKJMNdmURiPAGmBlGBJ87w03BEYShpQsKMJP7MDtvg8fKnNuZUhj9c9cCQo%2FaMGIMCyIA%2BpB2s8Oxjyeih4wN0MXsOAMdtt%2FpMqYLF%2Bav1YeIIQYGEMtC3jGQ0XHtgKsw38OOZvFvp8b2HIz3vWehj9cHOAMLsnNGNpwpEg5GgkmKYC1QkQPmi5bqGwzE7nxcbK4rwW6zAsYXZUCnAs4%2BZlAVCY9w7PmM9e6HJXAseweC5RfN61OW7JwrtuNgDLBTlkUxJzNEo4EsG4roErjVaQTVB5AcAy1ilhXktRxK80xmux7gH2hvwgAZ0ZcFIar6AIkT2T5oIog7mARzsBj9o2z49V%2BQsteFmK%2FxuIdwRACLBskHBHsMxnhwE%2FG4FH1WRt5Rgwwi9ygWtiXlEYr424UsU5XQglXe5uIcLyDUchwCm8xZFQcSFVsNOG5dCIo5YPwwze7vHIfJdHbIdXMs3T0uIbtiSzCsj6%2FwWgTEaCmUzxq8ESn4pStkUx6Ao4DYhjzlQbjDk%2BZ4OYMWuCdnuOL3cHKFyE7Zkk6Hrg%2BuAWoCx7QxiUClRBkhtBFETQi6ETwiCBfgLdGJQku38Hh3e1%2BMiJeTrbm2w900He2mTaltinVviw1Hz4%2FDKDQc7f3znJV5XmFVe%2BUwCi2B3BeB7xMWGxL%2BlzJBuyaNc512gwP9XitJzgerLCC3qImN7PPrfOZP9N3m77fPlKBt2OCQdfgfSMV1gWuK6B4TgmwZUpONeQ5satSSAtjlEKvcjI2sUBSBuaNs%2FOKdy4xtHLmnzNZalRRQ4zfmrbJi7Ymtlhxq%2F3%2Bzz%2B5gofSxSnGw7frlgcq1icuKE%2FdAlAGh%2FUOVUFHxWST9gpY%2F40E26NTCU8K6f4c8%2FmgHBQeOxFMNR1mqLOQ8CyusDZxhYWKhZcrcCiBeOF0WUMaw1KGbEjingvs1yujXtnedFHFDdnSZMQfRtqLjQsWMlg2xTJdwOa3Zj88BaWrwU4fcW3Dt1C78qAwW0VPnMPrL54hXoYcuhSyIH5mMNVj7vynC%2F2Ep6XNicFIHRH17OT%2FGGueByPqpSELPLHzp2sodlPk2VWOZ2vcp8UrNJgQQeMiSa36oxrtIjUeV4kZ96ukQYRvLACsQ2tCmgb6g1ojYHvGy9wXANHiB8EEGcQJNAfwlIAlzuwFhn3z2K4asN8FaZ9ON3msUmfMMzp7x%2Fnx2PF9bWYbGeD3eMec%2Bd6eNtqbG6HnDjVJmw4bLXgk0Jz10wVqeDYfy7xJyI%2FqZ9Xb%2FKyvJ0LYoigRpuAVPfZzhgdeYix%2FF%2BJyVkiZkrsoUOXKruYEYoIB0dd5iJtLiFZtjyIczgWgqxArQqWY5ZfJMkyJDbmgBJAmEI%2Fgm5k8sFaBP0AvpvAGQ%2BszHSnkz6%2FEWRcSxWJ0ogwZ9CPcXc0YJAiBil116KjNNmkzxSC4U9uZvL7PRYqFjuvB9z7RpuXbWzO4bMPjwkUi0KQakjJiYWL1BewGLJGFYmHJWyaTFFVJzmvJ5iSd1NFo8mLqFLQt6DWBL8KM5thdQ1OXzRJLs1NC5wVnWBZAVIMhBRzfvsU3LsLlgOY70A7gCsprOWmzCoFaU6eKFKlafgWYeaQVm3qlsDKNXbdYWItoe9IeklO35bM3DPFvpUQ%2B5tXuX54Ez9hyzv4fa3466zLH6gESyjmLc28vZuv4LCkV2iIaU6KOo%2BJhJ62UGimCOhoG1v3sXWfATUGdh2ur8K%2FpdBqgFTmRrWGLIM4NbucCbNS1ktfCSAXoKTJBbk2eSFQsA24M4IrddhWg%2BNzrO6dpBFlcL5HfXcT3fIZn%2FTZO%2BlyeT6ifrZDtx1younw8ck6B08scs%2FWCoeUZn5Pk2dvbfKPdpGIjqiQI0mfX1AeH9ewX1ziCafJFgHHtUZ7iqp0eVMO2U0NZd1FhYQH6DNHi0Nyih3K4hsnV8DW4JaSvkxoljmvitouhSkCJQCJAZZhIJSiqRRHXQXNHB4dh9ldYEvu7ycED22lP9tnuWmxH%2FjeYsjcpR6eL1jMUh704BNRxIdCjbU64JX5Hk%2FsaPHizgZnFWCXikTYIF2%2Brut8PVmDuM2dFjyZhXxEaf5ShyAdLhNwypnhat1j33CVxfoE1Gf56e7rHP9OD7oBtJpm51y9XglytWEVRub8oPjJSgBFVXaKRJkVoTNU8O9n4dUl2HMLjYHEe%2B0K0cFJ7tCa%2B04usrMXIzsxvwSMS0F3h8%2Frec6nOyFfazosRMCYZ8Kx9r8KIWVu2K7z38LiNy0JXotPBsv84jDnkVDyY%2BoK2HVIchb8izhenUZfcHfWYu8tVVzcG4JHxDFuHPOKY%2FOGMk5wQ9qWequcB1A0RFqilMbvRfyy0tTqPonCCCkByVAzO%2Bxw37TPlktDhm9FjCUarvUKmaw5t73JX2XwpVzx1uYaLMcm%2FEQB%2FIbO04EmPwdZG9IA8hqkA0iHIJpGk7vjEK%2BAVWU2zTg6HHI0iJFUQVugLGOwPw5UTdyrQt2leVHurXXZW%2FYBN16XHqDXJXSqzKJol8tq4dvw6jxcGxiQQQrneyaHTNX5j6bP5%2BYGfHVHw%2BiIhQAmfOhnEGTmuu1NEArGq%2B%2BkF9BGHeYKhOSC2%2BRTbpPP10Ke6HZ4dDBgp%2FYNqKjcTV2AKWJZWuvDEIrGiA06vZwXpArScnYgTblLtBnAxkX%2F8FYHrg5gmMDFvhFVt7T4l9sm%2BGyiOdaJCvBqvZt897pBbW5Kay5XN%2FNkmvGkgKdyiz8ahLSSBFzLyGCtjaFKGoBaGC%2FQhdy%2B0REWO1%2FueI7REYky5xNlVlz0CmdWYG4AqYDpJsdmJ%2Fhcy%2BOlmg3nu8bjxA9jIJKnRrM7FZ5ujDNblXzGSiBcgnhgfFsok9G0Wr8ptaE0lksVK9fG08pzaWF0rIyrn5g3o%2BxAc6xe4aHdkzzcdHmpF0OU%2FwgmQoIb%2Br4tLf50rMXdTZuX8jaEa8ZwWQxPwAgYCqNL3Z8X%2FUGujDekxc6XoaGAdmiMfzsgmmzw2%2BMVHnYEx6PMAHpPDEWV6SJfb03zc60Kv6M7JP1FyBOT2SmmPWVjVILYOA9QRdDemBsA3%2B%2FAtxdgNeMrt0%2Bxe6rC3%2BkNM8b33FQ40%2BBW%2BdtGhdvp8V%2FBEkQDkxxFUX4sud4IlSDkhqSoi%2Bx%2BahFOLkMIv7JrnMdcwdUyXN67X4xo49KZ5sqmGT5UkTzVu85c2C00xsap74anpT7Qwrj8d%2BbhzCr%2FsHeGgxMVvhSm6yXzffHlqBCmxrg%2Bz1hwWxbyu%2BGAN%2BLQKLxS6pZTXcuCYQoLfZau9%2FliJ%2BFA3eXXGg5vCN5ZSXvPfDN0wxmKjI8kdj2%2BECZ8gZwH51bYWWtwaGqKQ0ECmab%2F2kWea9SJIs0LrkVYdyCOTVLUN3GnxOjn8qMfSIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjAB80B7%2FA4t1%2F6lyzbV6AAAAAElFTkSuQmCC" alt="Hosted By: 4EVERLAND"/></a><a target="_blank" rel="noopener" href="https://github.com/FedDragon1/FedDragon1.github.io"><img src="https://img.shields.io/badge/Source-Github-83855d?style=flat&amp;logo=github" alt="Source: Github"/></a><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-83855d?style=flat&amp;logo=image%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAHwAAAB8CAMAAACcwCSMAAAAMFBMVEX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F9Or7hAAAAAD3RSTlMAESIzRFVmd4iZqrvM3e5GKvWZAAAE5UlEQVR42u1b24KFJgwUCBhAwv9%2Fbe%2FteoKMskjv87jLYUgYYhJxG4fzHHOuJ%2BTM7N22GDbwUbvIHMwqZsel3uJgt4A5Sn2I8jJ%2FOOoQjtf8b1jqMITNUur19EFRj9HPyeyoUyh%2BwuN1GsksNxtAvmX8Ds9SZuZAROSZOecKEIeNN7HLy8G1463n3P2FG%2BO21y6X6IEZxkd5wfXucpL0YA5%2F7bH9OTddcAvbmagUn3KH2XAVZJgdcLOZj8nRfIs7220YNrXTPNjvxuNALAhehj3vBBzSMZg0yG4FjJ8PkgwXewydz%2FEzG8Bg5SjRY6cfTtLfRAYjAUZ8WQwW%2Bjw3Yk%2BdYaXhXsHu8YbPcyN2sVsL3yxwEXu6dXp4tdyRG7t4IrYMxuzShLbPmPp2tbnDQJegJuaRP%2BY3wC9hex1G%2BqZnJcf34bumu7VOV%2FYp06P%2BxwJYJXjw9wXgRlbtn2kJs9bc8cefC07zlphutRCXGq5MZy23ZTsOiORRfLFEwRPBc%2BiIdiIyTwTvGq9Lx2F7li9V7O5y5j2f4tRu7846N87gy2ljVci%2BsbkZkwhXQ0ej9SubLqvObGH3plOdmXqCUaG1tNQmo14L7t6IQ6maV49ahimQQugkKog9KLLYel1zY3aruBG7VeGsIK3nCiAOrK%2BTE50Hf2ogPWmHacFyheB%2BnLEfOQzD9KOwJwpZ5aEq%2BWMi2j98YbubTtsO4jpftUboj6lLUKZIaKrTrOZ0H7aeCQwwPGgRlqAVJE5XAZk2jQ%2Fy3D%2FlviMHK79RK1XsykLdc9aKy2fyvCFxnMBfnfTu2rmE7QKffKVfphSl6y%2BYSy92hnR1JOrXvUDMD%2BogGk5nADmeuJXFNkUe%2BuT2iRMfIXTICawRkI9lnvR3Iv%2BfHAjOvSY4P37U%2FIOpzJvn3A4GGT9OLv3wKt1njqM2vOqfe3tPDh4sqWtWrtG2aZFVz%2BN4RZ87TzUBwag02VW02pDUrDxaSA6TCdWZ06lytKqhEtqFRwuSCZhGxcv3wbuc2dpWi6pgPFAxSiCtfpdJRHxOtW3TXGQi8izdBrv%2F0JFBXQmuEDtK7e%2FDpsNFAy4IEixYWmfqpaoDRbBf3ClGCHBHkLxmUCgCdlUIhefcWmGoRAblb3ywwh3Gt6BbMu7htQ3xoIgH7yKLjipR26Nh4%2F0LbdL0l2m7a9oiQbeDW9hTQ6hE3xvzxRzd7VOF2ygKW2E%2BEJmbVlgAY652OC1vAoInVdCmr0K5OtWy3PTWSIc74UsNPzrNfvNnGB5Wv%2BYAfQ4xvTdbbn2rn7v9tmMBtbLP6n8tdbwp4GmXljpeqUosTNfMSqVXxulafpfb4Usb%2BuV9XPzyHt8V4bXXFjRUyhDWXtjAjq9h9VUVJYsF7FZxx6e3uPhlreHbGFGxx7fvaYvD%2B%2FPmtRG%2Bqdyw6KrQxHZnzR3G9mhi473gCuYRe6FvmZ1w5YbZp%2B5pbyyQG7BPf58QCq7UMfsEvaIejliu1G%2FftLbK4WNXOUE7JIcb801I%2BH3u3MX%2BtHftt4p5IlTttQdJTFatlTiVx02h8Y3XKDnzL8j5WPA5h%2BqHrP6QRYPKgq9Y1n81Nf5FAG4GjSPa%2BTwoLabGcHExNYblIekVfrnc8k%2B9L5FWtBZClHub%2FbYMbu%2BH0RKD3VbD0M45y4k1Jw7f8fWPsLFGZr3MQTIAAAAASUVORK5CYII%3D" alt="Copyright: BY-NC-SA 4.0"/></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script type="text/javascript" src="https://yijuzhan.com/api/word.php?m=js"></script><script>document.getElementsByClassName("footer_custom_text")[0].innerHTML = `${str[0]} —— ${str[1]}`</script><script>let element=document.getElementById("footer_site_ontime"),startDate=new Date(element.innerText);function getTimeDelta(){let t=new Date,n=new Date(t-startDate),e=n.getFullYear()-1970,p=n.getMonth(),s=n.getDate()-1,a=n.getHours(),r;return[e,p,s,a,n.getMinutes(),n.getSeconds()]}function displayTimeDelta(){let t=getTimeDelta(),n;n=0===t[1]?`On time ${t[2].toString().padStart(2,"0")}D ${t[3].toString().padStart(2,"0")}h ${t[4].toString().padStart(2,"0")}m ${t[5].toString().padStart(2,"0")}s❤`:0===t[0]?`On time ${t[1]}M ${t[2].toString().padStart(2,"0")}D ${t[3].toString().padStart(2,"0")}h ${t[4].toString().padStart(2,"0")}m ${t[5].toString().padStart(2,"0")}s ❤`:`本站已经运行了 ${t[0]}Y ${t[1]}M ${t[2].toString().padStart(2,"0")}D ${t[3].toString().padStart(2,"0")}h ${t[4].toString().padStart(2,"0")}m ${t[5].toString().padStart(2,"0")}s ❤`,element.innerText=n}function startCountDown(){displayTimeDelta(),setTimeout(startCountDown,1e3)}startCountDown();</script><script>const player = new Plyr('#video-fullscreen')</script><script id="canvas_nest" defer="defer" color="131, 133, 93" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>